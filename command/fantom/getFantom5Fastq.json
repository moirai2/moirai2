{"https://moirai2.github.io/schema/daemon/input":"$libid","https://moirai2.github.io/schema/daemon/bash":["outdir=\"$workdir/out\"","output=$(getFantom5Fastq.pl -r read1 -o $outdir $libid)"],"https://moirai2.github.io/schema/daemon/script":{"https://moirai2.github.io/schema/daemon/script/name":"getFantom5Fastq.pl","https://moirai2.github.io/schema/daemon/script/code":["#!/usr/bin/perl","use strict 'vars';","use Cwd;","use DirHandle;","use File::Basename;","use FileHandle;","use Getopt::Std;","use IO::File;","use DBI;","use vars qw($opt_o  $opt_r);","getopts('o:r:');","my $library_id=$ARGV[0];","my $outdir=defined($opt_o)?$opt_o:\".\";","my $read=$opt_r;","my @files=get_solexa_files($library_id,$outdir,$read);","foreach my $file(@files){","\tmy $original=$file->[4];","\tmy $copy=$file->[5];","\tmy $command=\"ln -s $original $copy\";","\tsystem($command);","\tprint \"$copy\\n\";","}","############################## get_solexa_files ##############################","sub get_solexa_files{","\tmy $library_id=shift();","\tmy $output_directory=shift();","\tmy $read=shift();","\tmy $server   = \"rlgsw63.gsc.riken.jp\";","\tmy $username = \"read\";","\tmy $password = \"read\";","\tmy $database = \"library_tracker\";","\tmy $dbh = DBI->connect( \"DBI:mysql:$database:$server\", $username, $password, { raiseError => 1, AutoCommit => 1 } ) or die \"connecting : $DBI::errstr\\n\";","\tmy $sth = $dbh->prepare( \"SELECT osc_sample_id, if( barcode_sequence is null, barcode_desc, barcode_sequence ) FROM application join library using( application_id ) join library_sample_list using( library_id ) join sample using( sample_id ) left join barcode on(library_sample_list.barcode_id=barcode.barcode_id) where rejected=false and on_hold=false and osc_lib_id='$library_id'\" );","\t$sth->execute();","\tmy @row = $sth->fetchrow_array;","\tmy $osc_sample_id = \"nosampleid\";","\tmy $barcode_exists;","\twhile( scalar( @row ) > 0 ) {","\t\tif( $row[ 0 ] ne \"\" ) { $osc_sample_id = $row[ 0 ]; }","\t\tif( $row[ 1 ] ne \"\" ) { $barcode_exists = 1; }","\t\t@row = $sth->fetchrow_array;","\t}","\t$sth->finish();","","\t# ask database again","\tmy $sth = $dbh->prepare( \"SELECT run_results_file, run_qc_success, run_start_date, run_actual_finish_date, lane_number FROM application join library l using(application_id) join lane on(l.library_id=lane.library_id) join run on(run.run_id=lane.run_id) where run_qc_success = 1 and rejected=false and on_hold=false and osc_lib_id='$library_id'\" );","\t$sth->execute();","\tmy @row = $sth->fetchrow_array;","\tmy @directories = ();","\tmy $sequencer_type;","\t$osc_sample_id = good_filename( $osc_sample_id );","\t$library_id = good_filename( $library_id );","\twhile( scalar( @row ) > 0 ) {","\t\tmy ( $directory, $qc_success, $start_date, $end_date, $lane ) = @row;","\t\tif( $qc_success != 1 ) { @row = $sth->fetchrow_array; next; } # make sure only successful one is used","\t\tif( $directory eq \"Sequence Fail\" ) { @row = $sth->fetchrow_array; next; } # also a key to check success/fail","\t\t$lane++; # increment by 1 since it's 1-base","\t\tmy $run_id = good_filename( get_filename( remove_slash( $directory ) ) ); # assumes last directory name is runid","\t\tmy @input_files1 = ();","\t\tmy @input_files2 = ();","\t\tif( defined( $read ) ) { @input_files1 = list_directory( 1, 0, \"PARENT PATH\", 0, \"s_${lane}_${read}_sequence.txt.bz2\", \"\", $directory ); }","\t\telse {","\t\t\t@input_files1 = list_directory( 1, 0, \"PARENT PATH\", 0, \"s_${lane}_1_sequence.txt.bz2\", \"\", $directory );","\t\t\t@input_files2 = list_directory( 1, 0, \"PARENT PATH\", 0, \"s_${lane}_2_sequence.txt.bz2\", \"\", $directory );","\t\t\tif(scalar(@input_files1)==0){@input_files1=list_directory(1,0,\"PARENT PATH\",0,\"s_${lane}_sequence.txt.bz2\",\"\",$directory);}","\t\t}","\t\tforeach my $input_file(@input_files1){","\t\t\tmy $read_id=\"read1\";","\t\t\tmy $lane_id=\"lane$lane\";","\t\t\tmy $output_file=\"$output_directory/$library_id.$run_id.$read_id.$lane_id.fq.bz2\";","\t\t\tpush( @directories,[$directory,$lane,$run_id,$read_id,$input_file,$output_file]);","\t\t}","\t\tforeach my $input_file(@input_files2){","\t\t\tmy $read_id=\"read2\";","\t\t\tmy $lane_id=\"lane$lane\";","\t\t\tmy $output_file=\"$output_directory/$library_id.$run_id.$read_id.$lane_id.fq.bz2\";","\t\t\tpush( @directories,[$directory,$lane,$run_id,$read_id,$input_file,$output_file]);","\t\t}","\t\t@row = $sth->fetchrow_array;","\t}","\t$sth->finish();","\treturn @directories;","\t$dbh->disconnect();","}","############################## list_directory ##############################","# list name of files in a directory/directories - 2007/10/25","# my @files = list_directory( $show_file, $show_directory, $parent, $recursive, $query, $unquery, @directories );","# my @files = list_directory( 1, 1, \"PARENT PATH\", -1, \"\", \"\", @directories );","# $parent = \"PARENT PATH\" will replace with the current directory name","# \"PARENT PATH\" was added because some people might not want original directory name attached and some people do","# I added so it can take care of IO::File too, since this means file exists and is readable and handled already by user","# if directory is \"\", it'll be handled as \".\"","sub list_directory {","\tmy @directories    = @_; # directories","\tmy $show_file      = shift( @directories ); # add file to array?","\tmy $show_directory = shift( @directories ); # add directory to array?","\tmy $parent         = shift( @directories ); # add parent string to array?","\tmy $recursive      = shift( @directories ); # recursively search?","\tmy $query          = shift( @directories ); # query used for grepping","\tmy $unquery        = shift( @directories ); # query used for deselecting","\tmy @array          = (); # results of file search","\t# return empty array, since directories aren't specified","\tif( scalar( @directories ) == 0 ) { return @array; } # return empty array","\t@directories = remove_slash( @directories ); # remove \"/\" from end of directories","\tforeach my $path ( map { split( /[;,]/, $_ ) }  @directories ) { # go through each directory/file","\t\tif( ref( $path ) eq \"IO::File\" ) { # in case of IO::File","\t\t\tif( $show_file != 0 ) { push( @array, $path ); } # remember :)","\t\t\tnext; # done so skip to the next path","\t\t} elsif( $path eq \"-\" ) { # in case of STDIN notation","\t\t\tif( $show_file != 0 ) { push( @array, $path ); } # remember :)","\t\t\tnext; # done so skip to the next path","\t\t} elsif( -f $path ) { # handles file beforehand","\t\t\tif( defined( $query ) && $query ne \"\" && ! grep( /$query/, $path ) ) { next; }","\t\t\tif( defined( $unquery ) && $unquery ne \"\" && grep( /$unquery/, $path ) ) { next; }","\t\t\tif( $show_file != 0 ) { push( @array, $path ); } # it's file, so remember","\t\t\tnext; # done so skip to the next path","\t\t} elsif( $path eq \"\" ) { # special case where it's handles as \".\"","\t\t} elsif( ! ( -d $path ) ) { next; } # it's not a directory, maybe alias?","\t\tmy $parent_path = ( $parent eq \"PARENT PATH\" ) ? $path : $parent; # handles parent path","\t\tmy $dh; # open directory handler","\t\tif( $path eq \"\" ) { if( ! ( $dh = DirHandle->new( \".\" ) ) ) { print STDERR \"Couldn't open current directory\\n\"; next; } }","\t\telsif( ! ( $dh = DirHandle->new( $path ) ) ) { print STDERR \"Couldn't open directory '$path'\\n\"; next; }","\t\tforeach my $file ( $dh->read() ) { # go through each file","\t\t\tif( $file =~ /^\\.\\.?/ ) { next; } # skip . and ..","\t\t\tmy $file_path = ( $path eq \"\" ) ? $file : \"$path/$file\";","\t\t\tmy $file_name = ( $parent_path eq \"\" ) ? $file : \"$parent_path/$file\";","\t\t\tif( -f $file_path ) { # file","\t\t\t\tif( defined( $query ) && $query ne \"\" && ! grep( /$query/, $file ) ) { next; }","\t\t\t\tif( defined( $unquery ) && $unquery ne \"\" && grep( /$unquery/, $file ) ) { next; }","\t\t\t\tif( $show_file != 0 ) { push( @array, $file_name ); }","\t\t\t} elsif( -d $file_path ) { # directory","\t\t\t\tif( $recursive != 0 ) { # go through recursively","\t\t\t\t\tpush( @array, list_directory( $show_file, $show_directory, $file_name, $recursive - 1, $query, $unquery, $file_path ) );","\t\t\t\t}","\t\t\t\tif( defined( $query ) && $query ne \"\" && ! grep( /$query/, $file ) ) { next; }","\t\t\t\tif( defined( $unquery ) && $unquery ne \"\" && grep( /$unquery/, $file ) ) { next; }","\t\t\t\tif( $show_directory != 0 ) { push( @array, $file_name . \"/\" ); }","\t\t\t}","\t\t}","\t\t# close directory handler","\t\tif( ! $dh->close() ) { print STDERR \"Couldn't close directory $path\\n\"; }","\t}","\t# sort array","\t@array = sort { compare_two_numbers( $a, $b ) } @array;","\treturn wantarray ? @array : $array[ 0 ]; # return final results","}","############################## is_number ##############################","# return 1 if value is number (+/-,decimal,e values are all OK) - 2007/03/09","# If array is an input, returns 1 if values are all numbers","# Undefined, HASH, ARRAY will return 0","# +12.345e+67 or -12.345e-67 are numers","# my $boolean = is_number( @array );","sub is_number {","\tif( scalar( @_ ) == 0 ) { return 0; } # it's not number, since it's empty...","\tfor( @_ ) { # go through inputs","\t\tif( ! defined( $_ ) ) { return 0; } # not defined -_-;...., so return 0","\t\tif( ref( $_ ) ne \"\" ) { return 0; } # not a scalar reference, scalar values return \"\"","\t\tif( ! /^[\\+\\-]?\\d+(\\.\\d*)?([Ee][\\+\\-]?\\d+)?$/ ) { return 0; } # not a number","\t}","\treturn 1; # all values are number","}","############################## remove_slash ##############################","# remove last \"/\", space, return, and tab from a directory name - 2007/01/24","# it will also take care of extra space, return, and tab at the beginning too","# my $directory   = remove_slash( $directory   );","# my @directories = remove_slash( @directories );","sub remove_slash {","\tmy @out = @_; # input/output","\tfor( @out ) { # go through array","\t\ts/^[\\n\\s\\t\\r]+//; # remove excess space before","\t\ts/[\\n\\s\\t\\r\\/]+$//; # remove \\/","\t}","\treturn wantarray ? @out : $out[ 0 ]; # return results","}","############################## good_filename ##############################","# cover file name into usable filename - 2008/07/28","# my $new_name = good_filename( $old_name );","# \" \" => \"_\"","# \"/\" => \"_\"","# \"\\\" => \"_\"","# \".\" => \"_\"","# \"*\" => \"_\"","# \"\"\" => \"_\"","# \"'\" => \"_\"","# \"#\" => \"_\"","# \"(\" => \"_\"","# \")\" => \"_\"","# \",\" => \"_\"","# \";\" => \"_\"","# \":\" => \"_\"","# \"%\" => \"_\"","# \"?\" => \"_\"","sub good_filename {","\tmy $filename = shift;","\t$filename =~ tr/ \\/\\\\\\.\\*\\\"\\'#\\(\\)\\,\\;\\:\\%\\?/_______________/;","\treturn $filename;","}","############################## get_filename ##############################","# return file name of specified file - 2007/01/24","# my $filename = get_filename( $filename );","sub get_filename {","\tmy @basenames = basenames( shift() );","\treturn $basenames[ 1 ];","}","############################## basenames ##############################","# return directory, file_name, base_name, file_suffix of a file - 2007/01/24","# my ( $directory, $file_name, $base_name, $file_suffix ) = basenames( $file );","sub basenames {","\tmy $file = $_[ 0 ]; # name of file","\tmy @out  = (); # output for directory, file name, base name, file suffix, file size","\t# separating directory and file","\tif( $file =~ /^(.+)\\/([^\\/]+)$/ ) { # divide by \"\\/\"","\t\t$out[ 0 ] = $1; # directory","\t\t$out[ 1 ] = $2; # file","\t} elsif( $file =~ /^(.*)\\/$/ ) { # ends with \"/\"","\t\t$out[ 0 ] = $1; # empty directory","\t\t$out[ 1 ] = \"\"; # file","\t} else { # couldn't separate","\t\t$out[ 0 ] = \"\"; # empty directory","\t\t$out[ 1 ] = $file; # file","\t}","\t# separating basename and suffix","\tif( $out[ 1 ] =~ /^(.+)\\.([^\\.]+)$/ ) { # divide by \"\\.\"","\t\t$out[ 2 ] = $1; # basename","\t\t$out[ 3 ] = $2; # suffix","\t} else { # couldn't separate","\t\t$out[ 2 ] = $out[ 1 ]; # basename","\t\t$out[ 3 ] = \"\"; # empty suffix","\t}","\treturn wantarray ? @out : $out[ 1 ]; # return array, or just file name","}","############################## print_table ##############################","sub print_table{","\tmy @out=@_;","\tmy $return_type=$out[0];","\tif(lc($return_type) eq \"print\"){$return_type=0;shift(@out);}","\telsif(lc($return_type) eq \"array\"){$return_type=1;shift(@out);}","\telsif(lc($return_type) eq \"stderr\"){$return_type=2;shift(@out);}","\telse{$return_type= 2;}","\tprint_table_sub($return_type,\"\",@out);","}","sub print_table_sub{","\tmy @out=@_;","\tmy $return_type=shift(@out);","\tmy $string=shift(@out);","\tmy @output=();","\tfor(@out){","\t\tif(ref( $_ ) eq \"ARRAY\"){","\t\t\tmy @array=@{$_};","\t\t\tmy $size=scalar(@array);","\t\t\tif($size==0){","\t\t\t\tif($return_type==0){print $string.\"[]\\n\";}","\t\t\t\telsif($return_type==1){push(@output,$string.\"[]\");}","\t\t\t\telsif($return_type==2){print STDERR $string.\"[]\\n\";}","\t\t\t}else{","\t\t\t\tfor(my $i=0;$i<$size;$i++){push(@output,print_table_sub($return_type,$string.\"[$i]=>\\t\",$array[$i]));}","\t\t\t}","\t\t} elsif(ref($_)eq\"HASH\"){","\t\t\tmy %hash=%{$_};","\t\t\tmy @keys=sort{$a cmp $b}keys(%hash);","\t\t\tmy $size=scalar(@keys);","\t\t\tif($size==0){","\t\t\t\tif($return_type==0){print $string.\"{}\\n\";}","\t\t\t\telsif($return_type==1){push( @output,$string.\"{}\");}","\t\t\t\telsif($return_type==2){print STDERR $string.\"{}\\n\";}","\t\t\t}else{","\t\t\t\tforeach my $key(@keys){push(@output,print_table_sub($return_type,$string.\"{$key}=>\\t\",$hash{$key}));}","\t\t\t}","\t\t}elsif($return_type==0){print \"$string\\\"$_\\\"\\n\";}","\t\telsif($return_type==1){push( @output,\"$string\\\"$_\\\"\");}","\t\telsif($return_type==2){print STDERR \"$string\\\"$_\\\"\\n\";}","\t}","\treturn wantarray?@output:$output[0];","}"]},"https://moirai2.github.io/schema/daemon/output":["$outdir","$output"]}
